const path = require('path')
const compiler = require('riot-compiler')
const { getOptions } = require('loader-utils')
const TAGS_NAMES_REGEX = /riot.tag2\(['|"](.+?)['|"],/g

/**
 * Generate the hmr code depending on the tags generated by the compiler
 * @param   { Array } tags - array of strings
 * @returns { string } the code needed to handle the riot hot reload
 */
function hotReload(tags) {
  return `
  if (module.hot) {
    module.hot.accept()
    if (module.hot.data) {
      ${tags.map(tag => `riot.reload('${tag}')`).join('\n')}
    }
  }`
}

/**
 * Compile using the riot compiler returning always an object with {map, code}
 * @param   { string } source - component source content
 * @param   { Object } opts   - compiler options
 * @param   { string } resourcePath - path to the component file
 * @returns { Object } result containing always the map and code keys
 */
function compile(source, opts, resourcePath) {
  const exec = () => compiler.compile(source, opts, resourcePath)
  return opts.sourcemap ? exec() : { code: exec(), map: false }
}

/**
 * Transforms the include options into a parser specific option
 * @param   { Object } opts - compiler options (incl. include option)
 * @param   { String } resourcePath - path to the component file
 * @returns { Object } result with transformed include for the parser
 */
function transformInclude(opts, resourcePath) {
  if (opts.include instanceof Array) {
    opts.include.push(path.parse(resourcePath).dir)
    opts.parserOptions = opts.parserOptions || {}
    opts.parserOptions.style = opts.parserOptions.style || {}
    switch (opts.style) {
      case 'less':
        opts.parserOptions.style.paths = opts.include
        break
      case 'sass':
        opts.parserOptions.style.includePaths = opts.include
        break
      case 'scss':
        opts.parserOptions.style.includePaths = opts.include
        break
      case 'stylus':
        opts.parserOptions.style.include = opts.include
        break
    }
    return opts
  }
}

module.exports = function(source) {
  // tags collection
  const tags = []

  // parse the user query
  const query = getOptions(this) || {}

  // normalise the query object in case of question marks
  const opts = Object.keys(query).reduce(function(acc, key) {
    acc[key.replace('?', '')] = query[key]
    return acc
  }, {})

  // compile and generate sourcemaps
  const {code, map} = compile(
    source,
    Object.assign(opts, {
      sourcemap: opts.sourcemap !== false && this.sourceMap
    }, transformInclude(opts, this.resourcePath)),
    this.resourcePath
  )

  // detect the tags names
  code.replace(TAGS_NAMES_REGEX, function(_, match) {
    tags.push(match)
  })

  // generate the output code
  const output = `
    var riot = require('riot')
    ${code}
    ${opts.hot ? hotReload(tags) : ''}
  `

  // cache this module
  if (this.cacheable) this.cacheable()

  // return code and sourcemap
  if (map) this.callback(null, output, map.toJSON())

  return output
}
